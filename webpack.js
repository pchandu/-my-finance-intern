/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/*!*******************!*\
  !*** ./bundle.js ***!
  \*******************/
eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function () {\n  function r(e, n, t) {\n    function o(i, f) {\n      if (!n[i]) {\n        if (!e[i]) {\n          var c = undefined;\n          if (!f && c) return require(i, !0);\n          if (u) return u(i, !0);\n          var a = new Error(\"Cannot find module '\" + i + \"'\");\n          throw a.code = \"MODULE_NOT_FOUND\", a;\n        }\n\n        var p = n[i] = {\n          exports: {}\n        };\n        e[i][0].call(p.exports, function (r) {\n          var n = e[i][1][r];\n          return o(n || r);\n        }, p, p.exports, r, e, n, t);\n      }\n\n      return n[i].exports;\n    }\n\n    for (var u = undefined, i = 0; i < t.length; i++) {\n      o(t[i]);\n    }\n\n    return o;\n  }\n\n  return r;\n})()({\n  1: [function (require, module, exports) {}, {}],\n  2: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        // 'path' module extracted from Node.js v8.11.1 (only the posix part)\n        // transplited with Babel\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n        'use strict';\n\n        function assertPath(path) {\n          if (typeof path !== 'string') {\n            throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n          }\n        } // Resolves . and .. elements in a path with directory names\n\n\n        function normalizeStringPosix(path, allowAboveRoot) {\n          var res = '';\n          var lastSegmentLength = 0;\n          var lastSlash = -1;\n          var dots = 0;\n          var code;\n\n          for (var i = 0; i <= path.length; ++i) {\n            if (i < path.length) code = path.charCodeAt(i);else if (code === 47\n            /*/*/\n            ) break;else code = 47\n            /*/*/\n            ;\n\n            if (code === 47\n            /*/*/\n            ) {\n                if (lastSlash === i - 1 || dots === 1) {// NOOP\n                } else if (lastSlash !== i - 1 && dots === 2) {\n                  if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46\n                  /*.*/\n                  || res.charCodeAt(res.length - 2) !== 46\n                  /*.*/\n                  ) {\n                      if (res.length > 2) {\n                        var lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1) {\n                          if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                          } else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                          }\n\n                          lastSlash = i;\n                          dots = 0;\n                          continue;\n                        }\n                      } else if (res.length === 2 || res.length === 1) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                      }\n                    }\n\n                  if (allowAboveRoot) {\n                    if (res.length > 0) res += '/..';else res = '..';\n                    lastSegmentLength = 2;\n                  }\n                } else {\n                  if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);\n                  lastSegmentLength = i - lastSlash - 1;\n                }\n\n                lastSlash = i;\n                dots = 0;\n              } else if (code === 46\n            /*.*/\n            && dots !== -1) {\n              ++dots;\n            } else {\n              dots = -1;\n            }\n          }\n\n          return res;\n        }\n\n        function _format(sep, pathObject) {\n          var dir = pathObject.dir || pathObject.root;\n          var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n\n          if (!dir) {\n            return base;\n          }\n\n          if (dir === pathObject.root) {\n            return dir + base;\n          }\n\n          return dir + sep + base;\n        }\n\n        var posix = {\n          // path.resolve([from ...], to)\n          resolve: function resolve() {\n            var resolvedPath = '';\n            var resolvedAbsolute = false;\n            var cwd;\n\n            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n              var path;\n              if (i >= 0) path = arguments[i];else {\n                if (cwd === undefined) cwd = process.cwd();\n                path = cwd;\n              }\n              assertPath(path); // Skip empty entries\n\n              if (path.length === 0) {\n                continue;\n              }\n\n              resolvedPath = path + '/' + resolvedPath;\n              resolvedAbsolute = path.charCodeAt(0) === 47\n              /*/*/\n              ;\n            } // At this point the path should be resolved to a full absolute path, but\n            // handle relative paths to be safe (might happen when process.cwd() fails)\n            // Normalize the path\n\n\n            resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n            if (resolvedAbsolute) {\n              if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';\n            } else if (resolvedPath.length > 0) {\n              return resolvedPath;\n            } else {\n              return '.';\n            }\n          },\n          normalize: function normalize(path) {\n            assertPath(path);\n            if (path.length === 0) return '.';\n            var isAbsolute = path.charCodeAt(0) === 47\n            /*/*/\n            ;\n            var trailingSeparator = path.charCodeAt(path.length - 1) === 47\n            /*/*/\n            ; // Normalize the path\n\n            path = normalizeStringPosix(path, !isAbsolute);\n            if (path.length === 0 && !isAbsolute) path = '.';\n            if (path.length > 0 && trailingSeparator) path += '/';\n            if (isAbsolute) return '/' + path;\n            return path;\n          },\n          isAbsolute: function isAbsolute(path) {\n            assertPath(path);\n            return path.length > 0 && path.charCodeAt(0) === 47\n            /*/*/\n            ;\n          },\n          join: function join() {\n            if (arguments.length === 0) return '.';\n            var joined;\n\n            for (var i = 0; i < arguments.length; ++i) {\n              var arg = arguments[i];\n              assertPath(arg);\n\n              if (arg.length > 0) {\n                if (joined === undefined) joined = arg;else joined += '/' + arg;\n              }\n            }\n\n            if (joined === undefined) return '.';\n            return posix.normalize(joined);\n          },\n          relative: function relative(from, to) {\n            assertPath(from);\n            assertPath(to);\n            if (from === to) return '';\n            from = posix.resolve(from);\n            to = posix.resolve(to);\n            if (from === to) return ''; // Trim any leading backslashes\n\n            var fromStart = 1;\n\n            for (; fromStart < from.length; ++fromStart) {\n              if (from.charCodeAt(fromStart) !== 47\n              /*/*/\n              ) break;\n            }\n\n            var fromEnd = from.length;\n            var fromLen = fromEnd - fromStart; // Trim any leading backslashes\n\n            var toStart = 1;\n\n            for (; toStart < to.length; ++toStart) {\n              if (to.charCodeAt(toStart) !== 47\n              /*/*/\n              ) break;\n            }\n\n            var toEnd = to.length;\n            var toLen = toEnd - toStart; // Compare paths to find the longest common path from root\n\n            var length = fromLen < toLen ? fromLen : toLen;\n            var lastCommonSep = -1;\n            var i = 0;\n\n            for (; i <= length; ++i) {\n              if (i === length) {\n                if (toLen > length) {\n                  if (to.charCodeAt(toStart + i) === 47\n                  /*/*/\n                  ) {\n                      // We get here if `from` is the exact base path for `to`.\n                      // For example: from='/foo/bar'; to='/foo/bar/baz'\n                      return to.slice(toStart + i + 1);\n                    } else if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                  }\n                } else if (fromLen > length) {\n                  if (from.charCodeAt(fromStart + i) === 47\n                  /*/*/\n                  ) {\n                      // We get here if `to` is the exact base path for `from`.\n                      // For example: from='/foo/bar/baz'; to='/foo/bar'\n                      lastCommonSep = i;\n                    } else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo'; to='/'\n                    lastCommonSep = 0;\n                  }\n                }\n\n                break;\n              }\n\n              var fromCode = from.charCodeAt(fromStart + i);\n              var toCode = to.charCodeAt(toStart + i);\n              if (fromCode !== toCode) break;else if (fromCode === 47\n              /*/*/\n              ) lastCommonSep = i;\n            }\n\n            var out = ''; // Generate the relative path based on the path difference between `to`\n            // and `from`\n\n            for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n              if (i === fromEnd || from.charCodeAt(i) === 47\n              /*/*/\n              ) {\n                  if (out.length === 0) out += '..';else out += '/..';\n                }\n            } // Lastly, append the rest of the destination (`to`) path that comes after\n            // the common path parts\n\n\n            if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {\n              toStart += lastCommonSep;\n              if (to.charCodeAt(toStart) === 47\n              /*/*/\n              ) ++toStart;\n              return to.slice(toStart);\n            }\n          },\n          _makeLong: function _makeLong(path) {\n            return path;\n          },\n          dirname: function dirname(path) {\n            assertPath(path);\n            if (path.length === 0) return '.';\n            var code = path.charCodeAt(0);\n            var hasRoot = code === 47\n            /*/*/\n            ;\n            var end = -1;\n            var matchedSlash = true;\n\n            for (var i = path.length - 1; i >= 1; --i) {\n              code = path.charCodeAt(i);\n\n              if (code === 47\n              /*/*/\n              ) {\n                  if (!matchedSlash) {\n                    end = i;\n                    break;\n                  }\n                } else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n              }\n            }\n\n            if (end === -1) return hasRoot ? '/' : '.';\n            if (hasRoot && end === 1) return '//';\n            return path.slice(0, end);\n          },\n          basename: function basename(path, ext) {\n            if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n            assertPath(path);\n            var start = 0;\n            var end = -1;\n            var matchedSlash = true;\n            var i;\n\n            if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n              if (ext.length === path.length && ext === path) return '';\n              var extIdx = ext.length - 1;\n              var firstNonSlashEnd = -1;\n\n              for (i = path.length - 1; i >= 0; --i) {\n                var code = path.charCodeAt(i);\n\n                if (code === 47\n                /*/*/\n                ) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                      start = i + 1;\n                      break;\n                    }\n                  } else {\n                  if (firstNonSlashEnd === -1) {\n                    // We saw the first non-path separator, remember this index in case\n                    // we need it if the extension ends up not matching\n                    matchedSlash = false;\n                    firstNonSlashEnd = i + 1;\n                  }\n\n                  if (extIdx >= 0) {\n                    // Try to match the explicit extension\n                    if (code === ext.charCodeAt(extIdx)) {\n                      if (--extIdx === -1) {\n                        // We matched the extension, so mark this as the end of our path\n                        // component\n                        end = i;\n                      }\n                    } else {\n                      // Extension does not match, so our result is the entire path\n                      // component\n                      extIdx = -1;\n                      end = firstNonSlashEnd;\n                    }\n                  }\n                }\n              }\n\n              if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n              return path.slice(start, end);\n            } else {\n              for (i = path.length - 1; i >= 0; --i) {\n                if (path.charCodeAt(i) === 47\n                /*/*/\n                ) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                      start = i + 1;\n                      break;\n                    }\n                  } else if (end === -1) {\n                  // We saw the first non-path separator, mark this as the end of our\n                  // path component\n                  matchedSlash = false;\n                  end = i + 1;\n                }\n              }\n\n              if (end === -1) return '';\n              return path.slice(start, end);\n            }\n          },\n          extname: function extname(path) {\n            assertPath(path);\n            var startDot = -1;\n            var startPart = 0;\n            var end = -1;\n            var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n            // after any path separator we find\n\n            var preDotState = 0;\n\n            for (var i = path.length - 1; i >= 0; --i) {\n              var code = path.charCodeAt(i);\n\n              if (code === 47\n              /*/*/\n              ) {\n                  // If we reached a path separator that was not part of a set of path\n                  // separators at the end of the string, stop now\n                  if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                  }\n\n                  continue;\n                }\n\n              if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n              }\n\n              if (code === 46\n              /*.*/\n              ) {\n                  // If this is our first dot, mark it as the start of our extension\n                  if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n                } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n              }\n            }\n\n            if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n              return '';\n            }\n\n            return path.slice(startDot, end);\n          },\n          format: function format(pathObject) {\n            if (pathObject === null || _typeof(pathObject) !== 'object') {\n              throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + _typeof(pathObject));\n            }\n\n            return _format('/', pathObject);\n          },\n          parse: function parse(path) {\n            assertPath(path);\n            var ret = {\n              root: '',\n              dir: '',\n              base: '',\n              ext: '',\n              name: ''\n            };\n            if (path.length === 0) return ret;\n            var code = path.charCodeAt(0);\n            var isAbsolute = code === 47\n            /*/*/\n            ;\n            var start;\n\n            if (isAbsolute) {\n              ret.root = '/';\n              start = 1;\n            } else {\n              start = 0;\n            }\n\n            var startDot = -1;\n            var startPart = 0;\n            var end = -1;\n            var matchedSlash = true;\n            var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n            // after any path separator we find\n\n            var preDotState = 0; // Get non-dir info\n\n            for (; i >= start; --i) {\n              code = path.charCodeAt(i);\n\n              if (code === 47\n              /*/*/\n              ) {\n                  // If we reached a path separator that was not part of a set of path\n                  // separators at the end of the string, stop now\n                  if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                  }\n\n                  continue;\n                }\n\n              if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n              }\n\n              if (code === 46\n              /*.*/\n              ) {\n                  // If this is our first dot, mark it as the start of our extension\n                  if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n                } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n              }\n            }\n\n            if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n              if (end !== -1) {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n              }\n            } else {\n              if (startPart === 0 && isAbsolute) {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n              } else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n              }\n\n              ret.ext = path.slice(startDot, end);\n            }\n\n            if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n            return ret;\n          },\n          sep: '/',\n          delimiter: ':',\n          win32: null,\n          posix: null\n        };\n        posix.posix = posix;\n        module.exports = posix;\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"_process\": 3\n  }],\n  3: [function (require, module, exports) {\n    // shim for using process in browser\n    var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n    // don't break things.  But we need to wrap it in a try catch in case it is\n    // wrapped in strict mode code which doesn't define any globals.  It's inside a\n    // function because try/catches deoptimize in certain engines.\n\n    var cachedSetTimeout;\n    var cachedClearTimeout;\n\n    function defaultSetTimout() {\n      throw new Error('setTimeout has not been defined');\n    }\n\n    function defaultClearTimeout() {\n      throw new Error('clearTimeout has not been defined');\n    }\n\n    (function () {\n      try {\n        if (typeof setTimeout === 'function') {\n          cachedSetTimeout = setTimeout;\n        } else {\n          cachedSetTimeout = defaultSetTimout;\n        }\n      } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n      }\n\n      try {\n        if (typeof clearTimeout === 'function') {\n          cachedClearTimeout = clearTimeout;\n        } else {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n      }\n    })();\n\n    function runTimeout(fun) {\n      if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n      } // if setTimeout wasn't available but was latter defined\n\n\n      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n          return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n          return cachedSetTimeout.call(this, fun, 0);\n        }\n      }\n    }\n\n    function runClearTimeout(marker) {\n      if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n      } // if clearTimeout wasn't available but was latter defined\n\n\n      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n          return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n          // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n          return cachedClearTimeout.call(this, marker);\n        }\n      }\n    }\n\n    var queue = [];\n    var draining = false;\n    var currentQueue;\n    var queueIndex = -1;\n\n    function cleanUpNextTick() {\n      if (!draining || !currentQueue) {\n        return;\n      }\n\n      draining = false;\n\n      if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n      } else {\n        queueIndex = -1;\n      }\n\n      if (queue.length) {\n        drainQueue();\n      }\n    }\n\n    function drainQueue() {\n      if (draining) {\n        return;\n      }\n\n      var timeout = runTimeout(cleanUpNextTick);\n      draining = true;\n      var len = queue.length;\n\n      while (len) {\n        currentQueue = queue;\n        queue = [];\n\n        while (++queueIndex < len) {\n          if (currentQueue) {\n            currentQueue[queueIndex].run();\n          }\n        }\n\n        queueIndex = -1;\n        len = queue.length;\n      }\n\n      currentQueue = null;\n      draining = false;\n      runClearTimeout(timeout);\n    }\n\n    process.nextTick = function (fun) {\n      var args = new Array(arguments.length - 1);\n\n      if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n          args[i - 1] = arguments[i];\n        }\n      }\n\n      queue.push(new Item(fun, args));\n\n      if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n      }\n    }; // v8 likes predictible objects\n\n\n    function Item(fun, array) {\n      this.fun = fun;\n      this.array = array;\n    }\n\n    Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    };\n\n    process.title = 'browser';\n    process.browser = true;\n    process.env = {};\n    process.argv = [];\n    process.version = ''; // empty string to avoid regexp issues\n\n    process.versions = {};\n\n    function noop() {}\n\n    process.on = noop;\n    process.addListener = noop;\n    process.once = noop;\n    process.off = noop;\n    process.removeListener = noop;\n    process.removeAllListeners = noop;\n    process.emit = noop;\n    process.prependListener = noop;\n    process.prependOnceListener = noop;\n\n    process.listeners = function (name) {\n      return [];\n    };\n\n    process.binding = function (name) {\n      throw new Error('process.binding is not supported');\n    };\n\n    process.cwd = function () {\n      return '/';\n    };\n\n    process.chdir = function (dir) {\n      throw new Error('process.chdir is not supported');\n    };\n\n    process.umask = function () {\n      return 0;\n    };\n  }, {}],\n  4: [function (require, module, exports) {\n    // const fetch = require('node-fetch');\n    // global.fetch = require(\"node-fetch\");\n    require('dotenv').config(); // const IEXtoken = process.env.IEX; \n    // const SStoken = process.env.SENTI;\n\n\n    var IEXtoken = \"sk_a63b3c4b777b4f21a95bebb96e41c92f\";\n    var SStoken = \"9894333eef0d3acad87d56495d3f07c177763f2e\"; // console.log(\"hello\");\n    // console.log(process.env);\n\n    document.addEventListener('keypress', function (e) {\n      if (e.key === 'Enter') {\n        var symbol = document.getElementById(\"ticker-input\").value;\n\n        if (symbol.length === 0 || symbol.length > 4) {\n          document.getElementById(\"company-name\").innerHTML = \"INVALID TICKER\";\n          document.getElementById(\"ev-to-rev\").innerHTML = \"INVALID\";\n          document.getElementById(\"price-to-sales\").innerHTML = \"INVALID\";\n          document.getElementById(\"peg-ratio\").innerHTML = \"INVALID\";\n          document.getElementById(\"beta\").innerHTML = \"INVALID\";\n          document.getElementById(\"profit-margin\").innerHTML = \"INVALID\";\n          document.getElementById(\"d-to-e\").innerHTML = \"INVALID\";\n          document.getElementById(\"rev-per-employee\").innerHTML = \"INVALID\";\n          document.getElementById(\"avg-10day-vol\").innerHTML = \"INVALID\";\n          document.getElementById(\"avg-30day-vol\").innerHTML = \"INVALID\";\n          document.getElementById(\"high-pt\").innerHTML = \"INVALID\";\n          document.getElementById(\"avg-pt\").innerHTML = \"INVALID\";\n          document.getElementById(\"low-pt\").innerHTML = \"INVALID\";\n        } else {\n          //check if the input is not blank\n          //pass the input into the first API call to get the stock quote data\n          //Social Sentiment Data\n          //grabbing industry id\n          fetch(\"https://cors-anywhere.herokuapp.com/https://socialsentiment.io/api/v1/stocks/\".concat(symbol.toUpperCase(), \"/\"), {\n            headers: {\n              Accept: \"application/json\",\n              Authorization: \"Token \".concat(SStoken)\n            }\n          }).then(function (res) {\n            return res.json();\n          }).then(function (data) {\n            //grabbing industry sentiment data\n            fetch(\"https://cors-anywhere.herokuapp.com/https://socialsentiment.io/api/v1/industries/\".concat(data.industry_id, \"/sentiment/daily/\"), {\n              headers: {\n                Accept: \"application/json\",\n                Authorization: \"Token \".concat(SStoken)\n              }\n            }).then(function (res) {\n              return res.json();\n            }).then(function (industryData) {\n              //grabbing sentiment data and making chart\n              fetch(\"https://cors-anywhere.herokuapp.com/https://socialsentiment.io/api/v1/stocks/\".concat(symbol.toUpperCase(), \"/sentiment/daily/\"), {\n                headers: {\n                  Accept: \"application/json\",\n                  Authorization: \"Token \".concat(SStoken)\n                }\n              }).then(function (res) {\n                return res.json();\n              }).then(function (data) {\n                var ctx = document.getElementById('myChart').getContext('2d');\n                var chart = new Chart(ctx, {\n                  // The type of chart we want to create\n                  type: 'line',\n                  // The data for our dataset\n                  data: {\n                    labels: [\"\".concat(data[0].date), \"\".concat(data[1].date), \"\".concat(data[2].date), \"\".concat(data[3].date), \"\".concat(data[4].date), \"\".concat(data[5].date), \"\".concat(data[6].date), \"\".concat(data[7].date)],\n                    datasets: [{\n                      label: 'Stock Sentiment Activity',\n                      backgroundColor: 'rgba(0,0,0,0)',\n                      borderColor: 'rgb(106,45,92)',\n                      yAxisID: 'A',\n                      data: [\"\".concat(data[0].activity), \"\".concat(data[1].activity), \"\".concat(data[2].activity), \"\".concat(data[3].activity), \"\".concat(data[4].activity), \"\".concat(data[5].activity), \"\".concat(data[6].activity), \"\".concat(data[7].activity)]\n                    }, {\n                      label: 'Stock Sentiment Score',\n                      backgroundColor: 'rgba(0,0,0,0)',\n                      borderColor: 'rgb(255,84,118)',\n                      yAxisID: 'B',\n                      data: [\"\".concat(data[0].score), \"\".concat(data[1].score), \"\".concat(data[2].score), \"\".concat(data[3].score), \"\".concat(data[4].score), \"\".concat(data[5].score), \"\".concat(data[6].score), \"\".concat(data[7].score)]\n                    }, {\n                      label: 'Industry Sentiment Activity',\n                      backgroundColor: 'rgba(0,0,0,0)',\n                      borderColor: 'rgb(29,58,20)',\n                      yAxisID: 'A',\n                      data: [\"\".concat(industryData[0].activity), \"\".concat(industryData[1].activity), \"\".concat(industryData[2].activity), \"\".concat(industryData[3].activity), \"\".concat(industryData[4].activity), \"\".concat(industryData[5].activity), \"\".concat(industryData[6].activity), \"\".concat(industryData[7].activity)]\n                    }, {\n                      label: 'Industry Sentiment Score',\n                      backgroundColor: 'rgba(0,0,0,0)',\n                      borderColor: 'rgb(130,212,187)',\n                      yAxisID: 'B',\n                      data: [\"\".concat(industryData[0].score), \"\".concat(industryData[1].score), \"\".concat(industryData[2].score), \"\".concat(industryData[3].score), \"\".concat(industryData[4].score), \"\".concat(industryData[5].score), \"\".concat(industryData[6].score), \"\".concat(industryData[7].score)]\n                    }]\n                  },\n                  // Configuration options go here\n                  options: {\n                    scales: {\n                      xAxes: [{\n                        gridLines: {\n                          display: false\n                        }\n                      }],\n                      yAxes: [{\n                        id: 'A',\n                        type: 'linear',\n                        position: 'left',\n                        scaleLabel: {\n                          display: true,\n                          labelString: 'Activity'\n                        },\n                        gridLines: {\n                          display: false\n                        }\n                      }, {\n                        id: 'B',\n                        type: 'linear',\n                        position: 'right',\n                        scaleLabel: {\n                          display: true,\n                          labelString: 'Score'\n                        },\n                        gridLines: {\n                          display: false\n                        }\n                      }]\n                    }\n                  }\n                });\n              });\n            });\n          }); //end of sentiment data fetching and charting\n\n          fetch(\"https://cloud.iexapis.com/stable/stock/\".concat(symbol, \"/quote?token=\").concat(IEXtoken)).then(function (response) {\n            return response.json();\n          }).then(function (data) {\n            document.getElementById(\"current-price-output\").innerHTML = \"$\".concat(data.iexClose);\n          }); //Advanced Stats -- \n\n          fetch(\"https://cloud.iexapis.com/stable/stock/\".concat(symbol, \"/advanced-stats?token=\").concat(IEXtoken)).then(function (response) {\n            return response.json();\n          }).then(function (data) {\n            // debugger\n            document.getElementById(\"ev-to-rev\").innerHTML = \"\".concat(data.enterpriseValueToRevenue, \"x\");\n            document.getElementById(\"price-to-sales\").innerHTML = \"\".concat(parseFloat(data.priceToSales.toFixed(2)), \"x\");\n            document.getElementById(\"peg-ratio\").innerHTML = \"\".concat(parseFloat(data.pegRatio).toFixed(2), \"x\");\n            document.getElementById(\"beta\").innerHTML = \"\".concat(parseFloat(data.beta).toFixed(2));\n            document.getElementById(\"profit-margin\").innerHTML = \"\".concat((data.profitMargin * 100).toFixed(3), \"%\");\n            document.getElementById(\"d-to-e\").innerHTML = \"\".concat(parseFloat(data.debtToEquity).toFixed(2));\n            document.getElementById(\"rev-per-employee\").innerHTML = \"$\".concat(data.revenuePerEmployee);\n          }); //Key Stats -- \n\n          fetch(\"https://cloud.iexapis.com/stable/stock/\".concat(symbol, \"/stats?token=\").concat(IEXtoken)).then(function (response) {\n            return response.json();\n          }).then(function (data) {\n            document.getElementById(\"avg-10day-vol\").innerHTML = data.avg10Volume;\n            document.getElementById(\"avg-30day-vol\").innerHTML = data.avg30Volume;\n            document.getElementById(\"company-name\").innerHTML = data.companyName;\n          }); //Analyst Recommendations -- \n\n          fetch(\"https://cloud.iexapis.com/stable/stock/\".concat(symbol, \"/recommendation-trends?token=\").concat(IEXtoken)).then(function (response) {\n            return response.json();\n          }).then(function (data) {\n            document.getElementById(\"buy-rating-body\").innerHTML = data[data.length - 1].ratingBuy + data[data.length - 1].ratingOverweight;\n            document.getElementById(\"hold-rating-body\").innerHTML = data[data.length - 1].ratingHold;\n            document.getElementById(\"sell-rating-body\").innerHTML = data[data.length - 1].ratingSell + data[data.length - 1].ratingUnderweight;\n            document.getElementById(\"#analysts\").innerHTML = data[data.length - 1].ratingSell + data[data.length - 1].ratingUnderweight + data[data.length - 1].ratingBuy + data[data.length - 1].ratingOverweight + data[data.length - 1].ratingHold;\n          }); //Price Targets\n\n          fetch(\"https://cloud.iexapis.com/stable/stock/\".concat(symbol, \"/price-target?token=\").concat(IEXtoken)).then(function (response) {\n            return response.json();\n          }).then(function (data) {\n            document.getElementById(\"high-pt\").innerHTML = \"$\".concat(data.priceTargetHigh.toFixed(0));\n            document.getElementById(\"avg-pt\").innerHTML = \"$\".concat(data.priceTargetAverage.toFixed(0));\n            document.getElementById(\"low-pt\").innerHTML = \"$\".concat(data.priceTargetLow.toFixed(0));\n          });\n        }\n      }\n    }); // const path = require('path')\n    // const PORT = process.env.PORT || 8000; \n    // app.get('/', (request, res) => {\n    //   res.sendFile(path.join(__dirname, './public/index.html'))\n    // })\n    // app.listen(PORT, () => {\n    //     console.log(__dirname);\n    //     console.log(`listening on ${PORT}`)\n    // })\n    // app.use(express.static('public'))\n  }, {\n    \"dotenv\": 5\n  }],\n  5: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        /* @flow */\n\n        /*::\n        \n        type DotenvParseOptions = {\n          debug?: boolean\n        }\n        \n        // keys and values from src\n        type DotenvParseOutput = { [string]: string }\n        \n        type DotenvConfigOptions = {\n          path?: string, // path to .env file\n          encoding?: string, // encoding of .env file\n          debug?: string // turn on logging for debugging purposes\n        }\n        \n        type DotenvConfigOutput = {\n          parsed?: DotenvParseOutput,\n          error?: Error\n        }\n        \n        */\n        var fs = require('fs');\n\n        var path = require('path');\n\n        function log(message\n        /*: string */\n        ) {\n          console.log(\"[dotenv][DEBUG] \".concat(message));\n        }\n\n        var NEWLINE = '\\n';\n        var RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/;\n        var RE_NEWLINES = /\\\\n/g;\n        var NEWLINES_MATCH = /\\n|\\r|\\r\\n/; // Parses src into an Object\n\n        function parse(src\n        /*: string | Buffer */\n        , options\n        /*: ?DotenvParseOptions */\n        )\n        /*: DotenvParseOutput */\n        {\n          var debug = Boolean(options && options.debug);\n          var obj = {}; // convert Buffers before splitting into lines and processing\n\n          src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n            // matching \"KEY' and 'VAL' in 'KEY=VAL'\n            var keyValueArr = line.match(RE_INI_KEY_VAL); // matched?\n\n            if (keyValueArr != null) {\n              var key = keyValueArr[1]; // default undefined or missing values to empty string\n\n              var val = keyValueArr[2] || '';\n              var end = val.length - 1;\n              var isDoubleQuoted = val[0] === '\"' && val[end] === '\"';\n              var isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"; // if single or double quoted, remove quotes\n\n              if (isSingleQuoted || isDoubleQuoted) {\n                val = val.substring(1, end); // if double quoted, expand newlines\n\n                if (isDoubleQuoted) {\n                  val = val.replace(RE_NEWLINES, NEWLINE);\n                }\n              } else {\n                // remove surrounding whitespace\n                val = val.trim();\n              }\n\n              obj[key] = val;\n            } else if (debug) {\n              log(\"did not match key and value when parsing line \".concat(idx + 1, \": \").concat(line));\n            }\n          });\n          return obj;\n        } // Populates process.env from .env file\n\n\n        function config(options\n        /*: ?DotenvConfigOptions */\n        )\n        /*: DotenvConfigOutput */\n        {\n          var dotenvPath = path.resolve(process.cwd(), '.env');\n          var encoding\n          /*: string */\n          = 'utf8';\n          var debug = false;\n\n          if (options) {\n            if (options.path != null) {\n              dotenvPath = options.path;\n            }\n\n            if (options.encoding != null) {\n              encoding = options.encoding;\n            }\n\n            if (options.debug != null) {\n              debug = true;\n            }\n          }\n\n          try {\n            // specifying an encoding returns a string instead of a buffer\n            var parsed = parse(fs.readFileSync(dotenvPath, {\n              encoding: encoding\n            }), {\n              debug: debug\n            });\n            Object.keys(parsed).forEach(function (key) {\n              if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n                process.env[key] = parsed[key];\n              } else if (debug) {\n                log(\"\\\"\".concat(key, \"\\\" is already defined in `process.env` and will not be overwritten\"));\n              }\n            });\n            return {\n              parsed: parsed\n            };\n          } catch (e) {\n            return {\n              error: e\n            };\n          }\n        }\n\n        module.exports.config = config;\n        module.exports.parse = parse;\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"_process\": 3,\n    \"fs\": 1,\n    \"path\": 2\n  }]\n}, {}, [4]);\n\n//# sourceURL=webpack://my-finance-intern/./bundle.js?");
/******/ })()
;